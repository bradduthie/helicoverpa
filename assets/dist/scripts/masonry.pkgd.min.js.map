{"version":3,"sources":["../bower_components/masonry-layout/masonry.js"],"names":["window","factory","define","amd","module","exports","require","Masonry","Outlayer","getSize","create","compatOptions","fitWidth","proto","prototype","_resetLayout","this","_getMeasurement","measureColumns","colYs","i","cols","push","maxY","horizontalColIndex","getContainerWidth","columnWidth","firstItem","items","firstItemElem","element","outerWidth","containerWidth","gutter","excess","mathMethod","Math","max","isFitWidth","_getOption","container","parentNode","size","innerWidth","_getItemLayoutPosition","item","remainder","colSpan","min","colPosMethod","options","horizontalOrder","colPosition","position","x","col","y","setHeight","outerHeight","setMax","_getTopColPosition","colGroup","_getTopColGroup","minimumY","apply","indexOf","groupCount","_getColGroupY","groupColYs","slice","_getHorizontalColPosition","hasSize","_manageStamp","stamp","stampSize","offset","_getElementOffset","isOriginLeft","firstX","left","right","lastX","firstCol","floor","lastCol","isOriginTop","stampMaxY","top","bottom","_getContainerSize","height","width","_getContainerFitWidth","unusedCols","needsResizeLayout","previousWidth"],"mappings":"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","file":"masonry.pkgd.min.js","sourcesContent":["/*!\n * Masonry v4.2.2\n * Cascading grid layout library\n * https://masonry.desandro.com\n * MIT License\n * by David DeSandro\n */\n\n( function( window, factory ) {\n  // universal module definition\n  /* jshint strict: false */ /*globals define, module, require */\n  if ( typeof define == 'function' && define.amd ) {\n    // AMD\n    define( [\n        'outlayer/outlayer',\n        'get-size/get-size'\n      ],\n      factory );\n  } else if ( typeof module == 'object' && module.exports ) {\n    // CommonJS\n    module.exports = factory(\n      require('outlayer'),\n      require('get-size')\n    );\n  } else {\n    // browser global\n    window.Masonry = factory(\n      window.Outlayer,\n      window.getSize\n    );\n  }\n\n}( window, function factory( Outlayer, getSize ) {\n\n'use strict';\n\n// -------------------------- masonryDefinition -------------------------- //\n\n  // create an Outlayer layout class\n  var Masonry = Outlayer.create('masonry');\n  // isFitWidth -> fitWidth\n  Masonry.compatOptions.fitWidth = 'isFitWidth';\n\n  var proto = Masonry.prototype;\n\n  proto._resetLayout = function() {\n    this.getSize();\n    this._getMeasurement( 'columnWidth', 'outerWidth' );\n    this._getMeasurement( 'gutter', 'outerWidth' );\n    this.measureColumns();\n\n    // reset column Y\n    this.colYs = [];\n    for ( var i=0; i < this.cols; i++ ) {\n      this.colYs.push( 0 );\n    }\n\n    this.maxY = 0;\n    this.horizontalColIndex = 0;\n  };\n\n  proto.measureColumns = function() {\n    this.getContainerWidth();\n    // if columnWidth is 0, default to outerWidth of first item\n    if ( !this.columnWidth ) {\n      var firstItem = this.items[0];\n      var firstItemElem = firstItem && firstItem.element;\n      // columnWidth fall back to item of first element\n      this.columnWidth = firstItemElem && getSize( firstItemElem ).outerWidth ||\n        // if first elem has no width, default to size of container\n        this.containerWidth;\n    }\n\n    var columnWidth = this.columnWidth += this.gutter;\n\n    // calculate columns\n    var containerWidth = this.containerWidth + this.gutter;\n    var cols = containerWidth / columnWidth;\n    // fix rounding errors, typically with gutters\n    var excess = columnWidth - containerWidth % columnWidth;\n    // if overshoot is less than a pixel, round up, otherwise floor it\n    var mathMethod = excess && excess < 1 ? 'round' : 'floor';\n    cols = Math[ mathMethod ]( cols );\n    this.cols = Math.max( cols, 1 );\n  };\n\n  proto.getContainerWidth = function() {\n    // container is parent if fit width\n    var isFitWidth = this._getOption('fitWidth');\n    var container = isFitWidth ? this.element.parentNode : this.element;\n    // check that this.size and size are there\n    // IE8 triggers resize on body size change, so they might not be\n    var size = getSize( container );\n    this.containerWidth = size && size.innerWidth;\n  };\n\n  proto._getItemLayoutPosition = function( item ) {\n    item.getSize();\n    // how many columns does this brick span\n    var remainder = item.size.outerWidth % this.columnWidth;\n    var mathMethod = remainder && remainder < 1 ? 'round' : 'ceil';\n    // round if off by 1 pixel, otherwise use ceil\n    var colSpan = Math[ mathMethod ]( item.size.outerWidth / this.columnWidth );\n    colSpan = Math.min( colSpan, this.cols );\n    // use horizontal or top column position\n    var colPosMethod = this.options.horizontalOrder ?\n      '_getHorizontalColPosition' : '_getTopColPosition';\n    var colPosition = this[ colPosMethod ]( colSpan, item );\n    // position the brick\n    var position = {\n      x: this.columnWidth * colPosition.col,\n      y: colPosition.y\n    };\n    // apply setHeight to necessary columns\n    var setHeight = colPosition.y + item.size.outerHeight;\n    var setMax = colSpan + colPosition.col;\n    for ( var i = colPosition.col; i < setMax; i++ ) {\n      this.colYs[i] = setHeight;\n    }\n\n    return position;\n  };\n\n  proto._getTopColPosition = function( colSpan ) {\n    var colGroup = this._getTopColGroup( colSpan );\n    // get the minimum Y value from the columns\n    var minimumY = Math.min.apply( Math, colGroup );\n\n    return {\n      col: colGroup.indexOf( minimumY ),\n      y: minimumY,\n    };\n  };\n\n  /**\n   * @param {Number} colSpan - number of columns the element spans\n   * @returns {Array} colGroup\n   */\n  proto._getTopColGroup = function( colSpan ) {\n    if ( colSpan < 2 ) {\n      // if brick spans only one column, use all the column Ys\n      return this.colYs;\n    }\n\n    var colGroup = [];\n    // how many different places could this brick fit horizontally\n    var groupCount = this.cols + 1 - colSpan;\n    // for each group potential horizontal position\n    for ( var i = 0; i < groupCount; i++ ) {\n      colGroup[i] = this._getColGroupY( i, colSpan );\n    }\n    return colGroup;\n  };\n\n  proto._getColGroupY = function( col, colSpan ) {\n    if ( colSpan < 2 ) {\n      return this.colYs[ col ];\n    }\n    // make an array of colY values for that one group\n    var groupColYs = this.colYs.slice( col, col + colSpan );\n    // and get the max value of the array\n    return Math.max.apply( Math, groupColYs );\n  };\n\n  // get column position based on horizontal index. #873\n  proto._getHorizontalColPosition = function( colSpan, item ) {\n    var col = this.horizontalColIndex % this.cols;\n    var isOver = colSpan > 1 && col + colSpan > this.cols;\n    // shift to next row if item can't fit on current row\n    col = isOver ? 0 : col;\n    // don't let zero-size items take up space\n    var hasSize = item.size.outerWidth && item.size.outerHeight;\n    this.horizontalColIndex = hasSize ? col + colSpan : this.horizontalColIndex;\n\n    return {\n      col: col,\n      y: this._getColGroupY( col, colSpan ),\n    };\n  };\n\n  proto._manageStamp = function( stamp ) {\n    var stampSize = getSize( stamp );\n    var offset = this._getElementOffset( stamp );\n    // get the columns that this stamp affects\n    var isOriginLeft = this._getOption('originLeft');\n    var firstX = isOriginLeft ? offset.left : offset.right;\n    var lastX = firstX + stampSize.outerWidth;\n    var firstCol = Math.floor( firstX / this.columnWidth );\n    firstCol = Math.max( 0, firstCol );\n    var lastCol = Math.floor( lastX / this.columnWidth );\n    // lastCol should not go over if multiple of columnWidth #425\n    lastCol -= lastX % this.columnWidth ? 0 : 1;\n    lastCol = Math.min( this.cols - 1, lastCol );\n    // set colYs to bottom of the stamp\n\n    var isOriginTop = this._getOption('originTop');\n    var stampMaxY = ( isOriginTop ? offset.top : offset.bottom ) +\n      stampSize.outerHeight;\n    for ( var i = firstCol; i <= lastCol; i++ ) {\n      this.colYs[i] = Math.max( stampMaxY, this.colYs[i] );\n    }\n  };\n\n  proto._getContainerSize = function() {\n    this.maxY = Math.max.apply( Math, this.colYs );\n    var size = {\n      height: this.maxY\n    };\n\n    if ( this._getOption('fitWidth') ) {\n      size.width = this._getContainerFitWidth();\n    }\n\n    return size;\n  };\n\n  proto._getContainerFitWidth = function() {\n    var unusedCols = 0;\n    // count unused columns\n    var i = this.cols;\n    while ( --i ) {\n      if ( this.colYs[i] !== 0 ) {\n        break;\n      }\n      unusedCols++;\n    }\n    // fit container to columns that have been used\n    return ( this.cols - unusedCols ) * this.columnWidth - this.gutter;\n  };\n\n  proto.needsResizeLayout = function() {\n    var previousWidth = this.containerWidth;\n    this.getContainerWidth();\n    return previousWidth != this.containerWidth;\n  };\n\n  return Masonry;\n\n}));\n"],"sourceRoot":"scripts/"}