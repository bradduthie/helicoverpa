---
title: "The helicoverpa package"
author: "Brad Duthie and Rose McKeon"
output:
  html_document: default
  pdf_document:
    fig_caption: yes
  word_document:
    fig_caption: yes
linestretch: 1
header-includes:
- \usepackage{amsmath}
- \usepackage{natbib}
- \usepackage{lineno}
- \linenumbers
- \bibliographystyle{amnatnat}
bibliography: references.bib
---

```{r, echo=FALSE}
library(shiny)
library(rhandsontable)
```


********************************************************************************

> **This notebook tracks progress on the development of [helicoverpa](https://bradduthie.github.io/helicoverpa/) R package, a BBSRC [FAPESP Newton Funded](http://www.fapesp.br/en/9552) Project to model how the spatial scale of heterogeneity in fungal isolate application and crop plant cultivation affects variation in the selection landscape for biopesticide resistance.**

********************************************************************************

<center>**[Go to comments](#comments)**</center>

********************************************************************************


<a name="contents">Contents:</a>
================================================================================

[Project updates](#updates)

 - **2018**

     - **JUL** [18](#u-18-JUL-2018), [23](#u-23-JUL-2018), [30](#u-30-JUL-2018)

[Project comments](#comments)

********************************************************************************

<a name="updates">Project updates:</a>
================================================================================

> <a name="u-30-JUL-2018">Update: 30 JUL 2018</a>

**Some general thoughts about code structure**

There are some high-level functions that will be useful to think about before coding; that is, functions that need to do something in sequence during simulation initialisation and then during each time step of the simulation. These functions will call subfunctions that run key routines -- I think that all of these function, and the outer function (e.g., `simulate_resistance`, which runs through multiple time steps to test a particular set of parameter combinations), should be written in C for efficiency. An R function can call `simulate_resistance` and return the results to R, or an outer C function can also call it and print results to a text file (faster and easier with the computing cluster). The point is to have a single funtion that everything feeds to that does the work by calling multiple subfunctions -- this workhorse function `simulate_resistance` will contain the main loop over $N$ `time_steps`.

Prior to the loop, there will be some initialisation of the landscape `LAND` and the pests `PEST`. This will include all of the values in each layer `LAND` based on parameter initialisation. The functions `initialise_land` and `initialise_pest` are therefore called once at the start of the simulation; they will need to decide the distribution of landscape values and pests, and the sizes of each. It will not be necessary to initialise the `PEST` traits, only their genomes (based on allele and loci parameters, dominance, etc.) and non-genetic attributes such as location and ID (sex might or might not be based on genome). Before starting the big loop, the key structures of `PEST` and `LAND` need to otherwise be built. Any other key data structures will need to be initialised -- I am thinking that the `simulate_resistance` function, or maybe some small other function, should send a vector of information so that everything can be stored handily, then individual parameter values can be set in the small outer function then compiled into the vector for ease of use.

After initialisation, one big loop will run the simulation over multiple time steps (some pseudocode below).

```
simulate_resistance(parameter_values){
    error_checks(parameter_values);
    initialise_land(LAND);
    initialise_pest(PEST);
    for(time_step = 0; time_step < time_max; time_step++){
        build_pest_traits(PEST, build_type);
        set_crops(LAND, crop_parameters);
        set_biopesticide(LAND, biopesticide_parameters);
        move_pest(PEST, move_parameters);
        feed_pest(PEST, LAND, feeding_parameters);
        kill_pest(PEST, LAND, death_parameters);
        reproduce_pest(PEST, evolution_parameters);
        collect_PEST_data(PEST);
        collect_LAND_data(LAND);
        summarise_time_step(PEST, LAND);
        status_check(PEST, LAND);
    }
    summarise_simulation();
}
```

Multiple events will occur in each time step, including (but not limited to) the following: The `build_pest_traits()` function will simply read in and out the `PEST` array, building the traits from the pest genome according to some `build_type` in each generation.  The `set_crops` function will assign `LAND` cel layer values basedon on the crop parameter values underlying, e.g., spatial heterogeneity; similarly, `set_biopesticide` will affect `LAND` cell layer values. Then the `move_pest` function will cause the pests to move according to some sort of disperal rules set in `parameter_values`. Note that the landscape and the pests have not interacted in the time step yet (though we can imagine the landscape affecting pest movement rules), and will now do so in `feed_pest`, where they will affect crops, followed by `kill_pest` and `reproduce_pest`, where they will suffer mortality and reproduce as a consequence of their interactions. **We might want to think about the order of these operations.** After pest reproduction (which will include sex and genetic -- but not trait -- transmission), then summary data on the pests and landscape need to be collected (could even have an option to print everything out at this point, but it might be a lot of information) -- followed by a sort of grand summary of the time step. When the whole simulation has finished, then the results can be printed.

Note also that some error checks and status checks will be useful, since we'll want to make this function able to run from R. The error checks will just make sure nothing will crash the simulation (some of this might be better programmed in R instead of C), while the `status_check` might look to see, e.g., if pests have gone extinct, or have some sort of rule for termination of the simulation if something happens.

I suspect that the above structure will need rearranging and rethinking, but it's a starting point. Subfunctions will be the difficult part, coding efficient ways of building traits from the genome, movement rules, reproduction, etc.

> <a name="u-23-JUL-2018">Update: 23 JUL 2018</a>

I have attempted to set this notebook up with [Disqus](https://disqus.com/) commenting enabled with [the universal code options](https://helicoverpa.disqus.com/admin/install/platforms/universalcode/) (embedded HTML), which will ideally allow everyone on the project to make comments on the notes.

Data structures
--------------------------------------------------------------------------------

There are two data structures that we need to think about in particular, and these include the **pests**, which will be represented individually, and the **landscape**, which will be a large 3D array. The biopesticide will not be modelled discretely, but through a change in landscape values.

**Pests** 

Pests will need to be represented by some sort of data structure. We could create a custom structure in C, but this would get messy if and when we decide to convert the model into an R package so that users can simulate by calling an R function. I really don't see why pests cannot be represented by a large table, which is how I have always represented individuals in the past, and I already [have the code](https://github.com/bradduthie/gmse/blob/master/src/resource.c#L344) for reading R tables into C. The way that this will work then is to have each individual represented by a different row in the table, with columns corresponding to individual traits. Some traits that will be important include:

- Individual ID
- Sex (female or male)
- Traits 1-T: This includes traits such as dispersal ability, location (x and y), fecundity, and resistance to different biopesticides
- Loci 1-L: This will be a diploid system with allele values ($A^{v}_{i}$) and dominance coefficients $A^{h}_{v}$, the notation of which will likely change, but three `double` values will be used for each haploid loci: 1. allele number ($i$), value ($v$), and dominance ($h$). Since alleles are diploid, we will need $6L$ `double` columns in total, which will be the last columns of the table (this is just easier)

The idea of each individual having its own ID and sex is fairly straightforward, but what I'm thinking we can do with the traits will be a bit different. We want the evolving genome to affect resistance through a evolving traits, such that the genome affects traits underlying resistance, which then affect the evolution of the genetic architecture itself. The idea then is that each trait will be modelled as a `double` real number that is 'visible' to selection -- in most cases we will want the value of each trait will be a function of the genome, but this wouldn't necessarily be a requirement (e.g., if we just wanted to fix dispersal ability to some value, we could set it to whatever we desire in the relevant row and column -- this will also be useful for location on the landscape, which will be represented by two values x and y). We could then write a specific modular function `build_traits`, which loops through each individual and derives a single number from the individual's genome, which is then placed in the relevant trait column (1-T). Trait columns can by dynamic -- we can have anywhere from 1 to T of them, and the value of T will need to be stored somewhere -- better, if in the code we define ID and Sex as traits, we can just have loci start at T (or T + 1 in R). 

By having a modular `build_traits` function, we can keep the code flexible enough to have different ways of deriving single trait values for any given genome. The genome itself is probably easiest to model by breaking it down into L blocks of six, taking up 6L total columns of the 2D **pest** array. The first three values of a block will be the number (1), value (2), and dominance (3) for an allele, while the next three values will be the same for a homologous allele at the locus. The dominance values could be compared to calculate which allele has a stronger effect, similar to @Duthie2016a [[code](https://github.com/bradduthie/Inbreeding)], and this could be pre-set or randomised in some way for different allele types. The values could mean whatever we want them to, but a good starting point would be to think of them as additively effecting one or more trait as in @Duthie2017 [[code](https://github.com/bradduthie/pre_post_cop)]. We could of course just have the allele numbers in the genome, with a separate lookup table to match them with values and dominance coefficients, but I actually think this would be slower and more difficult to code. The `build_traits` function will loop through all of the loci, gathering in the relevant values to build each trait -- a sub-function (e.g., `calc_trait`) could do this for an individual trait, identifying where and what in the genome should be used to make a single trait such as resistance to a particular biopesticide. So, for example, the pest data structure for one (non ID or Sex) trait and one locus would look like this:

```{r}
simple_pests <- matrix(data = 0, nrow = 4, ncol = 9);
colnames(simple_pests) <- c("ID", "Sex", "Trait_1", "L1A1_i", "L1A1_v", 
                            "L1A1_h", "L1A2_i", "L1A2_v", "L1A2_h");
simple_pests[,1] <- 1:4;
simple_pests[,2] <- c(0, 1, 0, 1);
simple_pests[,3] <- runif(n = 4);
simple_pests[,4] <- sample(x = 1:2, size = 4, replace = TRUE);
simple_pests[,7] <- sample(x = 1:2, size = 4, replace = TRUE);
print(simple_pests);
```

I've not included the allele values or dominance coefficients for alleles 1 and 2. Note that in the columns 'L1' refers to locus 1, and 'A1' and 'A2' refer to alleles 1 and 2, respectively. As mentioned earlier, these will need to be represented by doubles in C, and the table could get quite big (well over 1000 columns, and potentially tens of thousands of rows). The benefit of doing all this is that we can potentially use multiple different types of infection models, as desired (e.g., gene for gene, quantative, threshold).

**Landscape**

The landscape will be modelled using a three dimensional array. We want space to be explicit, and the easiest way to do this is to have the first two dimensions of the array correspond to the x and y locations on a region of landscape. Interactions can happen at the scale of landscape cells (array elements), and distance between cells in any location can allow for explicit spatial processes (typically, count the number of cells in any of 8 directions, including diagonally, but other neighbour distances could be used, or cells could be hexagonal if there is good reason to do it). Having different cells with different values allows for landscape level heterogeneity (could also make values autocorrelated as desired as in @Duthie2013). Perhaps each cell starts with having some ID for the farm, as in the case of the 8 by 8 landscape below (actually x and y dimensions will be a variable in the model -- I usually use 100 by 100, with a torus landscape that wraps around itself to avoid edge effects).

```{r}
land_IDs <- matrix(data = 0, nrow = 8, ncol = 8);
land_IDs[1:2, 1:8] <- 1;
land_IDs[3:6, 1:5] <- 2;
land_IDs[3:8, 6:8] <- 3;
land_IDs[7:8, 1:3] <- 4;
land_IDs[7:8, 4:5] <- 5;
print(land_IDs);
```

So each of five farms or types of farms (or something else) are represented in the landscape. But we need lots of pieces of information for each cell, including what is planted on the cell, local environmental variables, and biopesticide applied. To get this, we can then add multiple layers on the z axis of a 3D array. So the landscape layer above is just the 'top', with multiple layers beneath coding critical information in a `land` array. Assume, for now that we need three layers (we'll actually need a lot more): (1) `land_IDs`, (2) crop used, (3) biopesticide 1 applied.

```{r}
land      <- array(data = 0, dim = c(8, 8, 3));
land[,,1] <- land_IDs;
land[,,2] <- sample(x = 1:3, size = 64, replace = TRUE);
land[,,3] <- round(x = runif(n = 64, min = 0, max = 1), digits = 3);
print(land);
```

The details aren't so important for now; what matters is the idea that we can represent information about landscape cells dynamically using array layers, which can therefore correspond to any number of things that we want to affect pests. The above structures can be initialised in R and diverted to a toy model that could help accomplish the short-term goals of the project, but also diverted to C to do the more intense simulatoin involving complex genetic architecture (we'll want a standalone C version too for speed and high-performance cluster computing). The toy model is probably the fist step -- to have something loop over time steps showing that something (e.g., allelic diversity) is maintained under variable landscapes, but is not when landscapes are homogenous (or when dispersal is infinite). Probably best to simplify the genetics as much as possible (e.g., 1 locus, fewer than 5 alleles) for this, then return some numbers that can be extracted from these data structures to build a graphic.

I see these two structures (**PEST** and **LAND**) as being the two most important ones to get right early on because these are the ones that will be used in almost every part of the model. The code will otherwise be written modularly, meaning that if we don't like the way that we're, e.g., deriving pest traits from their genetic architecture, or setting dispersal rules, or modelling sex, then we can simply rewrite the specific function that does these things and plug it back into the model. With this, some list or vector is also needed to hold parameter values (**PARA**), at lesat from the transition from R to C.



> <a name="u-18-JUL-2018">Update: 18 JUL 2018</a>

I have now initialised this lab notebook for the helicoverpa R package and model.

Comments {#comments}
--------------------------------------------------------------------------------

<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL; https://bradduthie.github.io/helicoverpa/notebook/helicoverpa_notes.html
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://helicoverpa.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                            

References
--------------------------------------------------------------------------------