---
title: "The helicoverpa package"
author: "Brad Duthie and Rose McKeon"
output:
  html_document: default
  pdf_document:
    fig_caption: yes
  word_document:
    fig_caption: yes
linestretch: 1
header-includes:
- \usepackage{amsmath}
- \usepackage{natbib}
- \usepackage{lineno}
- \linenumbers
- \bibliographystyle{amnatnat}
bibliography: references.bib
---

```{r, echo=FALSE}
library(shiny)
library(rhandsontable)
```


********************************************************************************

> **This notebook tracks progress on the development of [helicoverpa](https://bradduthie.github.io/helicoverpa/) R package, a BBSRC [FAPESP Newton Funded](http://www.fapesp.br/en/9552) Project to model how the spatial scale of heterogeneity in fungal isolate application and crop plant cultivation affects variation in the selection landscape for biopesticide resistance.**

*******************************************************************************

<a name="contents">Contents:</a>
================================================================================

[Project updates](#updates)

 - **2018**

     - **JUL** [18](#u-18-JUL-2018), [23](#u-23-JUL-2018)

[Project comments](#comments)

********************************************************************************

<a name="updates">Project updates:</a>
================================================================================

> <a name="u-23-JUL-2018">Update: 23 JUL 2018</a>

I have attempted to set this notebook up with [Disqus](https://disqus.com/) commenting enabled with [the universal code options](https://helicoverpa.disqus.com/admin/install/platforms/universalcode/) (embedded HTML), which will ideally allow everyone on the project to make comments on the notes.

Data structures
--------------------------------------------------------------------------------

There are two data structures that we need to think about in particular, and these include the **pests**, which will be represented individually, and the **landscape**, which will be a large 3D array. The biopesticide will not be modelled discretely, but through a change in landscape values.

**Pests** 

Pests will need to be represented by some sort of data structure. We could create a custom structure in C, but this would get messy if and when we decide to convert the model into an R package so that users can simulate by calling an R function. I really don't see why pests cannot be represented by a large table, which is how I have always represented individuals in the past, and I already [have the code](https://github.com/bradduthie/gmse/blob/master/src/resource.c#L344) for reading R tables into C. The way that this will work then is to have each individual represented by a different row in the table, with columns corresponding to individual traits. Some traits that will be important include:

- Individual ID
- Sex (female or male)
- Traits 1-T: This includes traits such as dispersal ability, location (x and y), fecundity, and resistance to different biopesticides
- Loci 1-L: This will be a diploid system with allele values ($A^{v}_{i}$) and dominance coefficients $A^{h}_{v}$, the notation of which will likely change, but three `double` values will be used for each haploid loci: 1. allele number ($i$), value ($v$), and dominance ($h$). Since alleles are diploid, we will need $6L$ `double` columns in total, which will be the last columns of the table (this is just easier)

The idea of each individual having its own ID and sex is fairly straightforward, but what I'm thinking we can do with the traits will be a bit different. We want the evolving genome to affect resistance through a evolving traits, such that the genome affects traits underlying resistance, which then affect the evolution of the genetic architecture itself. The idea then is that each trait will be modelled as a `double` real number that is 'visible' to selection -- in most cases we will want the value of each trait will be a function of the genome, but this wouldn't necessarily be a requirement (e.g., if we just wanted to fix dispersal ability to some value, we could set it to whatever we desire in the relevant row and column -- this will also be useful for location on the landscape, which will be represented by two values x and y). We could then write a specific modular function `build_traits`, which loops through each individual and derives a single number from the individual's genome, which is then placed in the relevant trait column (1-T). Trait columns can by dynamic -- we can have anywhere from 1 to T of them, and the value of T will need to be stored somewhere -- better, if in the code we define ID and Sex as traits, we can just have loci start at T (or T + 1 in R). 

By having a modular `build_traits` function, we can keep the code flexible enough to have different ways of deriving single trait values for any given genome. The genome itself is probably easiest to model by breaking it down into L blocks of six, taking up 6L total columns of the 2D **pest** array. The first three values of a block will be the number (1), value (2), and dominance (3) for an allele, while the next three values will be the same for a homologous allele at the locus. The dominance values could be compared to calculate which allele has a stronger effect, similar to @Duthie2016a [[code](https://github.com/bradduthie/Inbreeding)], and this could be pre-set or randomised in some way for different allele types. The values could mean whatever we want them to, but a good starting point would be to think of them as additively effecting one or more trait as in @Duthie2017 [[code](https://github.com/bradduthie/pre_post_cop)]. We could of course just have the allele numbers in the genome, with a separate lookup table to match them with values and dominance coefficients, but I actually think this would be slower and more difficult to code. The `build_traits` function will loop through all of the loci, gathering in the relevant values to build each trait -- a sub-function (e.g., `calc_trait`) could do this for an individual trait, identifying where and what in the genome should be used to make a single trait such as resistance to a particular biopesticide. So, for example, the pest data structure for one (non ID or Sex) trait and one locus would look like this:

```{r}
simple_pests <- matrix(data = 0, nrow = 4, ncol = 9);
colnames(simple_pests) <- c("ID", "Sex", "Trait_1", "L1A1_i", "L1A1_v", 
                            "L1A1_h", "L1A2_i", "L1A2_v", "L1A2_h");
simple_pests[,1] <- 1:4;
simple_pests[,2] <- c(0, 1, 0, 1);
simple_pests[,3] <- runif(n = 4);
simple_pests[,4] <- sample(x = 1:2, size = 4, replace = TRUE);
simple_pests[,7] <- sample(x = 1:2, size = 4, replace = TRUE);
print(simple_pests);
```

I've not included the allele values or dominance coefficients for alleles 1 and 2. Note that in the columns 'L1' refers to locus 1, and 'A1' and 'A2' refer to alleles 1 and 2, respectively. As mentioned earlier, these will need to be represented by doubles in C, and the table could get quite big (well over 1000 columns, and potentially tens of thousands of rows). The benefit of doing all this is that we can potentially use multiple different types of infection models, as desired (e.g., gene for gene, quantative, threshold).

**Landscape**

The landscape will be modelled using a three dimensional array. We want space to be explicit, and the easiest way to do this is to have the first two dimensions of the array correspond to the x and y locations on a region of landscape. Interactions can happen at the scale of landscape cells (array elements), and distance between cells in any location can allow for explicit spatial processes (typically, count the number of cells in any of 8 directions, including diagonally, but other neighbour distances could be used, or cells could be hexagonal if there is good reason to do it). Having different cells with different values allows for landscape level heterogeneity (could also make values autocorrelated as desired as in @Duthie2013). Perhaps each cell starts with having some ID for the farm, as in the case of the 8 by 8 landscape below (actually x and y dimensions will be a variable in the model -- I usually use 100 by 100, with a torus landscape that wraps around itself to avoid edge effects).

```{r}
land_IDs <- matrix(data = 0, nrow = 8, ncol = 8);
land_IDs[1:2, 1:8] <- 1;
land_IDs[3:6, 1:5] <- 2;
land_IDs[3:8, 6:8] <- 3;
land_IDs[7:8, 1:3] <- 4;
land_IDs[7:8, 4:5] <- 5;
print(land_IDs);
```

So each of five farms or types of farms (or something else) are represented in the landscape. But we need lots of pieces of information for each cell, including what is planted on the cell, local environmental variables, and biopesticide applied. To get this, we can then add multiple layers on the z axis of a 3D array. So the landscape layer above is just the 'top', with multiple layers beneath coding critical information in a `land` array. Assume, for now that we need three layers (we'll actually need a lot more): (1) `land_IDs`, (2) crop used, (3) biopesticide 1 applied.

```{r}
land      <- array(data = 0, dim = c(8, 8, 3));
land[,,1] <- land_IDs;
land[,,2] <- sample(x = 1:3, size = 64, replace = TRUE);
land[,,3] <- round(x = runif(n = 64, min = 0, max = 1), digits = 3);
print(land);
```

The details aren't so important for now; what matters is the idea that we can represent information about landscape cells dynamically using array layers, which can therefore correspond to any number of things that we want to affect pests. The above structures can be initialised in R and diverted to a toy model that could help accomplish the short-term goals of the project, but also diverted to C to do the more intense simulatoin involving complex genetic architecture (we'll want a standalone C version too for speed and high-performance cluster computing). The toy model is probably the fist step -- to have something loop over time steps showing that something (e.g., allelic diversity) is maintained under variable landscapes, but is not when landscapes are homogenous (or when dispersal is infinite). Probably best to simplify the genetics as much as possible (e.g., 1 locus, fewer than 5 alleles) for this, then return some numbers that can be extracted from these data structures to build a graphic.

I see these two structures (**PEST** and **LAND**) as being the two most important ones to get right early on because these are the ones that will be used in almost every part of the model. The code will otherwise be written modularly, meaning that if we don't like the way that we're, e.g., deriving pest traits from their genetic architecture, or setting dispersal rules, or modelling sex, then we can simply rewrite the specific function that does these things and plug it back into the model. With this, some list or vector is also needed to hold parameter values (**PARA**), at lesat from the transition from R to C.



> <a name="u-18-JUL-2018">Update: 18 JUL 2018</a>

I have now initialised this lab notebook for the helicoverpa R package and model.

Comments {.comments}
--------------------------------------------------------------------------------

<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL; https://bradduthie.github.io/helicoverpa/notebook/helicoverpa_notes.html
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://helicoverpa.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                            

References
--------------------------------------------------------------------------------